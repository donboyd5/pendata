---
format:
  html:
    toc: true
    toc-depth: 4
    page-layout: full
    css: wider.css
---

# Constants

```{r}
#| label: setup

GROOT <- rprojroot::find_root(rprojroot::has_file(".git/index"))
source(fs::path(GROOT, "data-raw", "R", "setup.R"))

```

```{r}
#| label: get-raw-data

# get the list of raw extracted data
rawdata <- readRDS(fs::path(DIRS$work, "frs_inputs_raw.rds"))
names(rawdata)

```


```{r}
#| label: data-for-experimentation

sheet <- "constants_assumptions"
info <- rawdata[[sheet]]$info
data <- rawdata[[sheet]]$data

```

## Clean up the data

### Determine variable types

```{r}
#| label: clean-data

count(data, datatype)
data |> filter(is.na(datatype)) # make sure all of these recs are all NAs

data2 <- data |>
  filter(!is.na(type)) |>
  mutate(
    vnumeric = ifelse(datatype == "numeric", as.numeric(value), NA_real_),
    vstring = ifelse(datatype == "string", value, NA_character_),
    vlogical = ifelse(datatype == "logical", as.logical(value), NA)
  )

data2 |> filter(!is.na(vlogical))
data2 |> filter(!is.na(vstring))
data2 |> filter(!is.na(vnumeric))

```

### Recover original Reason variable names

```{r}
#| label: Reason-names

count(data2, class)

prefixes <- c(
  "admin",
  "eco",
  "eco_eso_judges",
  "eso",
  "judges",
  "non_special",
  "regular",
  "senior_management",
  "special"
)

data3 <- data2 |>
  mutate(
    original = case_when(
      class %in% prefixes ~ paste0(class, "_", variable),
      class == "all" ~ variable,
      .default = NA_character_
    )
  ) |>
  relocate(original, .after = variable)

skimr::skim(data3)
data3

```

## Show the slightly cleaned data

```{r}
#| label: show-data
#| output: true
#| column: page

DT::datatable(
  data3,
  width = "100%",
  options = list(scrollX = TRUE, scrollY = '1500px', pageLength = 20),
  filter = "top"
)

# # datatable(ptargets, options = list(scrollX = TRUE, scrollY = '400px', paging = TRUE))

# datatable(
#   ptargets |>
#     select(-table_description),
#   options = list(scrollX = TRUE, scrollY = '1500px', pageLength = 20),
#   filter = "top"
# ) |>
#   formatCurrency(columns = c("ptarget"), currency = "", digits = 0)

```

## Convert from data frame to a list

```{r}

# in case we want it, make a list categorized by data type

types <- c("numeric", "string", "logical")

list_split <- data3 |>
  filter(!is.na(original), datatype %in% types) |>
  rowwise() |>
  mutate(
    value = list(
      if (datatype == "numeric") {
        vnumeric
      } else if (datatype == "string") {
        vstring
      } else {
        vlogical
      }
    )
  ) |>
  ungroup() |>
  select(datatype, vname = original, value) |>
  group_split(datatype) |>
  (\(lst) set_names(lst, map_chr(lst, ~ unique(.x$datatype))))() |>
  map(~ deframe(.x[, c("vname", "value")]))

# flatten the list
list_flat <- purrr::flatten(list_split)


```


## Save cleaned constants data to working folder

```{r}
#| output: true

saveRDS(data3, fs::path(DIRS$work, "constants_assumptions_tbl.rds"))

saveRDS(list_flat, fs::path(DIRS$work, "constants_assumptions.rds"))

```

```{r}
#| label: stop
#| echo: false

knitr::knit_exit()
```

```{r}
#| eval: false

# mylist is a flat list, mylist_split is split by datatype
mylist <- data3 |>
  filter(!is.na(original)) |>
  filter(datatype %in% c("numeric", "string", "logical")) |>
  rowwise() |>
  mutate(
    value = list(
      if (datatype == "numeric") {
        vnumeric
      } else if (datatype == "string") {
        vstring
      } else if (datatype == "logical") {
        vlogical
      } else {
        NULL
      }
    )
  ) |>
  ungroup() |>
  select(vname = original, value) |>
  deframe()

types <- c("numeric", "string", "logical")

mylist_split <- data3 |>
  filter(!is.na(original), datatype %in% types) |>
  rowwise() |>
  mutate(
    value = list(
      if (datatype == "numeric") {
        vnumeric
      } else if (datatype == "string") {
        vstring
      } else {
        vlogical
      }
    )
  ) |>
  ungroup() |>
  select(datatype, vname = original, value) |>
  group_split(datatype) |>
  (\(lst) set_names(lst, map_chr(lst, ~ unique(.x$datatype))))() |>
  map(~ deframe(.x[, c("vname", "value")]))

flatlist <- purrr::flatten(mylist_split)

```

